import * as React from 'react'
import edgeDraggingDetection from './EdgeDraggingDetection'

import { Coordinates } from './types'
import { Props as ElementProps } from './DraggableCanvasElement'

export type GenerateElementCallbacks<Id> = (
  id: Id,
) => {
  onDragStart: ElementProps['onDragStart']
  onDrag: ElementProps['onDrag']
  onDrop: ElementProps['onDrop']
  onDropAnimationEnd: ElementProps['onDropAnimationEnd']
}

export type ChildrenFunctionParams<Id> = {
  generateElementCallbacks: GenerateElementCallbacks<Id>
  wrapperRef: (el: Maybe<HTMLElement>) => void
}

type Props<Id> = {
  getWrapperEl?: () => Maybe<HTMLElement>
  detectScrollEvents?: boolean
  detectEdgeDragging?: boolean
  onEdgeDragging?: (delta: Coordinates) => void
  onElementDragStart?: (id: Id, ev: MouseEvent) => void
  onElementDrag?: (id: Id, x: number, y: number) => void
  onElementDrop?: (id: Id) => void
  onElementDropAnimationEnd?: (id: Id) => void
  children: (params: ChildrenFunctionParams<Id>) => React.ReactNode
}

// This component shouldn't be PureComponent, because it uses "children function" pattern
// The function can stay referentially equal, but resulting data generated by it can change
// PureComponent would break this functionality
export default class DraggableCanvas<Id> extends React.Component<Props<Id>> {
  wrapperEl: Maybe<HTMLElement> = null

  draggedElementInfo: Maybe<{ id: Id; x: number; y: number }> = null

  scrolling = false
  scrollingRAFId: number | null = null
  lastScrollPosition = { top: NaN, left: NaN }
  stopDraggingDetection: Maybe<() => void> = null

  componentWillUnmount() {
    const wrapperEl = this.getWrapperEl()

    if (this.scrollingRAFId) cancelAnimationFrame(this.scrollingRAFId)
    if (wrapperEl) {
      wrapperEl.removeEventListener('scroll', this.onScroll)
    }
  }

  getWrapperEl = (): Maybe<HTMLElement> => {
    const { getWrapperEl } = this.props

    return (
      this.wrapperEl ||
      (typeof getWrapperEl === 'function' ? getWrapperEl() : null)
    )
  }

  onScroll = () => {
    if (this.scrolling) return

    this.scrolling = true

    this.scrollingRAFId = requestAnimationFrame(() => {
      const wrapperEl = this.getWrapperEl()
      if (!wrapperEl || !this.draggedElementInfo) return

      const { scrollLeft, scrollTop } = wrapperEl

      const delta = {
        x: scrollLeft - this.lastScrollPosition.left,
        y: scrollTop - this.lastScrollPosition.top,
      }
      const { id, x, y } = this.draggedElementInfo

      this.lastScrollPosition = {
        top: scrollTop,
        left: scrollLeft,
      }
      this.scrolling = false

      this.onElementDrag(id, x + delta.x, y + delta.y)
    })
  }

  onElementDragStart = (id: Id, ev: MouseEvent): void => {
    const wrapperEl = this.getWrapperEl()
    const {
      detectScrollEvents,
      detectEdgeDragging,
      onElementDragStart,
      onEdgeDragging,
    } = this.props

    if (wrapperEl) {
      if (detectScrollEvents) {
        this.lastScrollPosition = {
          top: wrapperEl.scrollTop,
          left: wrapperEl.scrollLeft,
        }
        wrapperEl.addEventListener('scroll', this.onScroll)
      }

      if (detectEdgeDragging) {
        this.stopDraggingDetection = edgeDraggingDetection({
          wrapperEl,
          initialMousePosition: { x: ev.clientX, y: ev.clientY },
          onEdgeDragging,
        })
      }
    }

    onElementDragStart && onElementDragStart(id, ev)
  }

  onElementDrag = (id: Id, x: number, y: number): void => {
    const { onElementDrag } = this.props

    this.draggedElementInfo = { id, x, y }

    onElementDrag && onElementDrag(id, x, y)
  }

  onElementDrop = (id: Id): void => {
    const wrapperEl = this.getWrapperEl()
    const { onElementDrop, detectEdgeDragging } = this.props

    this.draggedElementInfo = null

    if (wrapperEl) {
      wrapperEl.removeEventListener('scroll', this.onScroll)
    }
    if (detectEdgeDragging) {
      this.stopDraggingDetection && this.stopDraggingDetection()
    }

    onElementDrop && onElementDrop(id)
  }

  onElementDropAnimationEnd = (id: Id): void => {
    const { onElementDropAnimationEnd } = this.props

    onElementDropAnimationEnd && onElementDropAnimationEnd(id)
  }

  generateElementCallbacks = (id: any) => {
    return {
      onDragStart: (ev: MouseEvent) => this.onElementDragStart(id, ev),
      onDrag: (x: number, y: number) => this.onElementDrag(id, x, y),
      onDrop: () => this.onElementDrop(id),
      onDropAnimationEnd: () => this.onElementDropAnimationEnd(id),
    }
  }

  render() {
    return this.props.children({
      generateElementCallbacks: this.generateElementCallbacks,
      wrapperRef: el => {
        this.wrapperEl = el
      },
    })
  }
}
